1. 采用字符串切割的方式进行处理（推荐使用）

#!/usr/bin/python
# -*- coding: utf8 -*-


def export_result(num):
    if None != num or "" != num:
        if len(str(num)) > 3:
            num_x, num_y = str(num).split('.')
            num = float(num_x + '.' + num_y[0:3])
            return num
        else:
            return num
    return


print(export_result(0.1236665))

2. 其他方式：

（1） %
例如：result为一个list，为result中每个值保留小数点后4位。 

result = [("%.4f" % i) for i in result]

Python 3.X对于浮点数默认提供17位数字的精度。

关于单精度和双精度：
单精度型float
双精度型double。在Turbo C中，
单精度型占4个字节（32位）内存空间，其数值范围为3.4E-38～3.4E+38，只能提供七位有效数字。
双精度型占8 个字节（64位）内存空间，其数值范围为1.7E-308～1.7E+308，可提供16位有效数字。

（2）format
"{0:.2f}".format(12345.67890)
result: '12345.68'

（3） 函数 round ceil floor
a. round(num,x)
如果只有一个数作为参数round(num)，返回一个最靠近的整数。如果出现.5，两边的距离都一样，round()取偶数。
round(3.245)
3
round(3.545)
4
如果有两位参数，则第二位为位数控制，如果最后一位是5，那么倒数第二位是奇数：舍弃，是偶数：进一。

>>> round(3.235, 2)#5前是3，5舍弃
3.23
>>> round(3.245, 2)#5前面是4，4进一=5
3.25

b. math模块的ceil(x)
取大于等于x的最小整数。

c. math模块的floor(x)
取小于等于x的最大整数。

（4）numpy
可以通过 np.set_printoptions 函数实现打印出来的位数控制。

参数： 
precision 控制输出精度， 
linewidth 控制输出宽度。 
e.g 
np.set_printoptions(linewidth=90)

（5）Pandas
控制台打印时显示的2位小数：

pd.set_option('precision', 2) 

或者整体

df.round(2)
————————————————
版权声明：本文为CSDN博主「鎏风」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/super_little_newbie/article/details/84639411

(6) 保留N位有效数字的脚本

#! /usr/bin/env python 
# -*- coding:utf-8 -*-
# @File    : test7.py
# @Author  : HWX763490
# @Time    : 2019/9/20 11:56
# @Desc    : 保留N位有效数字


def format(f, n):
    flag = 0
    s = str(f)
    for i in s:
        if (i == '.'):
            n -= 1
        if (i != '0') & (i != '.'):
            return float(s[:flag + n + 1])
        flag += 1


f = format(0.0125450, 3)
print(f)



python中实现精确的浮点数运算详解

计算机智能处理可数集合的运算，但是全体实数是不可数的，所以计算机只能用一些奇怪的方法来拟合他，于是就产生了浮点数。下面这篇文章主要给大家介绍了关于python中实现精确浮点数运算的相关资料，需要的朋友可以参考借鉴，下面随着小编来一起学习学习吧。
为什么说浮点数缺乏精确性？

在开始本文之前，让我们先来谈谈浮点数为什么缺乏精确性的问题，其实这不是Python的问题，而是实数的无限精度跟计算机的有限内存之间的矛盾。

举个例子，假如说我只能使用整数（即只精确到个位，计算机内的浮点数也只有有限精度，以C语言中的双精度浮点数double为例，精度为52个二进制位），要表示任意实数（无限精度）的时候我就只能通过舍入(rounding)来近似表示。

比如1.2我会表示成1，2.4表示成2，3.6表示成4.

所以呢？

在算1.2 - 1.2的时候，由于计算机表示的问题，我算的实际上是1 - 1，结果是0，碰巧蒙对了；

在算1.2 + 1.2 - 2.4的时候，由于计算机表示的问题，我算的实际上是1 + 1 - 2，结果是0，再次蒙对了；

但是在算1.2 + 1.2 + 1.2 - 3.6的时候，由于计算机表示的问题，我算的实际上是1 + 1 + 1 - 4，结果是-1，运气没那么好啦！

这里的1.2, 2.4, 3.6就相当于你问题里的0.1, 0.2和0.3，1, 2, 4则是真正在计算机内部进行运算的数值，我说清楚了吗？

其他请看IEEE 754浮点数标准，比如CSAPP第二章啥的（虽然估计你没兴趣看）。

另：不仅仅是浮点数的在计算机内部的表示有误差，运算本身也可能会有误差。比如整数2可以在计算机内准确表示，但是要算根号2就有误差了；再比如两个浮点数相除，本来两个数都是精确表示的，但除的结果精度却超出了计算机内实数的表示范围，然后就有误差了。

好了，下面话不多说了，开始本文的正文：

起步
浮点数的一个普遍的问题是它们不能精确的表示十进制数。

>>> a = 4.2
>>> b = 2.1
>>> a + b
6.300000000000001
>>> (a + b) == 6.3
False
>>>
这是由于底层 CPU 和IEEE 754 标准通过自己的浮点单位去执行算术时的特征。看似有穷的小数, 在计算机的二进制表示里却是无穷的。

一般情况下，这一点点的小误差是允许存在的。如果不能容忍这种误差（比如金融领域），那么就要考虑用一些途径来解决这个问题了。

Decimal
使用这个模块不会出现任何小误差。

>>> from decimal import Decimal
>>> a = Decimal('4.2')
>>> b = Decimal('2.1')
>>> a + b
Decimal('6.3')
>>> print(a + b)
6.3
>>> (a + b) == Decimal('6.3')
True
尽管代码看起来比较奇怪，使用字符串来表示数字，但是 Decimal 支持所有常用的数学运算。 decimal 模块允许你控制计算的每一方面，包括数字位数和四舍五入。在这样做之前，需要创建一个临时上下文环境来改变这种设定：

>>> from decimal import Decimal, localcontext
>>> a = Decimal('1.3')
>>> b = Decimal('1.7')
>>> print(a / b)
0.7647058823529411764705882353
>>> with localcontext() as ctx:
...  ctx.prec = 3
...  print(a / b)
...
0.765
>>> with localcontext() as ctx:
...  ctx.prec = 50
...  print(a / b)
...
0.76470588235294117647058823529411764705882352941176
>>>
由于 Decimal 的高精度数字自然也就用字符串来做展示和中转。

总结

总的来说，当涉及金融领域时，哪怕是一点小小的误差在计算过程中都是不允许的。因此 decimal 模块为解决这类问题提供了方法。
